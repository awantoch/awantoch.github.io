{"version":3,"sources":["scripts/console.js"],"names":["resolver","resolve","options","callback","resolveString","element","getAttribute","randomCharacter","characters","min","max","length","Math","floor","random","getRandomInteger","doResolverEffect","offset","partialString","substring","doRandomiserEffect","timeout","iterations","setTimeout","nextOptions","Object","assign","textContent","strings","counter","document","querySelector","$","removeClass","css"],"mappings":";AAEA,IAAMA,EAAW,CACfC,QAAS,SAAiBC,EAASC,GAE3BC,IAAAA,EAAgBF,EAAQE,eAAiBF,EAAQG,QAAQC,aAAa,wBAOnEC,SAAAA,EAAgBC,GAChBA,OAAAA,GALiBC,EAKW,EALNC,EAKSF,EAAWG,OAAS,EAJnDC,KAAKC,MAAMD,KAAKE,UAAYJ,EAAMD,EAAM,IAAMA,IAD9CM,IAAiBN,EAAKC,GAmCtBM,SAAAA,EAAiBd,EAASC,GAC3BC,IAAAA,EAAgBF,EAAQE,cAExBa,GADaf,EAAQM,WACZN,EAAQe,QACjBC,EAAgBd,EAAce,UAAU,EAAGF,IA/B1CG,SAAAA,EAAmBlB,EAASC,GAC7BK,IAAAA,EAAaN,EAAQM,WAErBH,GADUH,EAAQmB,QACRnB,EAAQG,SAClBa,EAAgBhB,EAAQgB,cAE1BI,EAAapB,EAAQoB,WAEzBC,WAAW,WACLD,GAAAA,GAAc,EAAG,CACbE,IAAAA,EAAcC,OAAOC,OAAO,GAAIxB,EAAS,CAACoB,WAAYA,EAAa,IAIvEjB,EAAQsB,YADS,IAAfL,EACoBJ,EAGAA,EAAcC,UAAU,EAAGD,EAAcP,OAAS,GAAKJ,EAAgBC,GAG/FY,EAAmBI,EAAarB,OACH,mBAAbA,GAChBA,KAEDD,EAAQmB,SAUXD,CAFwBK,OAAOC,OAAO,GAAIxB,EAAS,CAACgB,cAAeA,IAE/B,WAC5BM,IAAAA,EAAcC,OAAOC,OAAO,GAAIxB,EAAS,CAACe,OAAQA,EAAS,IAE7DA,GAAUb,EAAcO,OAC1BK,EAAiBQ,EAAarB,GACD,mBAAbA,GAChBA,MAKNa,CAvDwBS,OAAOC,OAAO,GAAIxB,EAAS,CAACE,cAAeA,IAuDjCD,KAIhCyB,EAAU,CACd,aACA,qBACA,4BACA,oBACA,SACA,eACA,eACA,eACA,gBAGEC,EAAU,EAER3B,EAAU,CAEde,OAAQ,EAERI,QAAS,EAETC,WAAY,GAEZd,WAAY,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,KAExLJ,cAAewB,EAAQC,GAEvBxB,QAASyB,SAASC,cAAc,2BAIlC,SAAS5B,IACPoB,WAAW,aACTM,GAEeD,EAAQjB,SACrBkB,EAAU,GAGRL,IAAAA,EAAcC,OAAOC,OAAO,GAAIxB,EAAS,CAACE,cAAewB,EAAQC,KACrE7B,EAASC,QAAQuB,EAAarB,IAC7B,KAGL6B,EAAE,WACAT,WAAW,WACTS,EAAE,QAAQC,YAAY,YACtBD,EAAE,QAAQE,IAAI,mBAAoB,SAClCX,WAAW,WACTvB,EAASC,QAAQC,EAASC,IACzB,MACF","file":"console.1ff6b576.map","sourceRoot":"../src","sourcesContent":["// Thank you Kevin (http://codepen.io/qkevinto/pen/WQVNWO)\n\nconst resolver = {\n  resolve: function resolve(options, callback) {\n    // The string to resolve\n    const resolveString = options.resolveString || options.element.getAttribute('data-target-resolver');\n    const combinedOptions = Object.assign({}, options, {resolveString: resolveString});\n    \n    function getRandomInteger(min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    };\n    \n    function randomCharacter(characters) {\n      return characters[getRandomInteger(0, characters.length - 1)];\n    };\n    \n    function doRandomiserEffect(options, callback) {\n      const characters = options.characters;\n      const timeout = options.timeout;\n      const element = options.element;\n      const partialString = options.partialString;\n\n      let iterations = options.iterations;\n\n      setTimeout(() => {\n        if (iterations >= 0) {\n          const nextOptions = Object.assign({}, options, {iterations: iterations - 1});\n\n          // Ensures partialString without the random character as the final state.\n          if (iterations === 0) {\n            element.textContent = partialString;\n          } else {\n            // Replaces the last character of partialString with a random character\n            element.textContent = partialString.substring(0, partialString.length - 1) + randomCharacter(characters);\n          }\n\n          doRandomiserEffect(nextOptions, callback)\n        } else if (typeof callback === \"function\") {\n          callback(); \n        }\n      }, options.timeout);\n    };\n    \n    function doResolverEffect(options, callback) {\n      const resolveString = options.resolveString;\n      const characters = options.characters;\n      const offset = options.offset;\n      const partialString = resolveString.substring(0, offset);\n      const combinedOptions = Object.assign({}, options, {partialString: partialString});\n\n      doRandomiserEffect(combinedOptions, () => {\n        const nextOptions = Object.assign({}, options, {offset: offset + 1});\n\n        if (offset <= resolveString.length) {\n          doResolverEffect(nextOptions, callback);\n        } else if (typeof callback === \"function\") {\n          callback();\n        }\n      });\n    };\n\n    doResolverEffect(combinedOptions, callback);\n  } \n}\n\nconst strings = [\n  'adventurer',\n  'computer scientist',\n  'cyber security enthusiast',\n  'software engineer',\n  'leader',\n  'entrepreneur',\n  'collaborator',\n  'fellow human',\n  'alec wantoch'\n];\n\nlet counter = 0;\n\nconst options = {\n  // Initial position\n  offset: 0,\n  // Timeout between each random character\n  timeout: 5,\n  // Number of random characters to show\n  iterations: 10,\n  // Random characters to pick from\n  characters: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'x', 'y', 'x', '#', '%', '&', '-', '+', '_', '?', '/', '\\\\', '='],\n  // String to resolve\n  resolveString: strings[counter],\n  // The element\n  element: document.querySelector('[data-target-resolver]')\n}\n\n// Callback function when resolve completes\nfunction callback() {\n  setTimeout(() => {\n    counter ++;\n    \n    if (counter >= strings.length) {\n      counter = 0;\n    }\n    \n    let nextOptions = Object.assign({}, options, {resolveString: strings[counter]});\n    resolver.resolve(nextOptions, callback);\n  }, 1000);\n}\n\n$(function(){\n  setTimeout(()=>{\n    $('body').removeClass('fade-out');\n    $('html').css('background-color', 'white');\n    setTimeout(()=>{\n      resolver.resolve(options, callback)\n    }, 3000);\n  }, 1000);\n  \n});"]}